%%{
#include "zeek/storage/Backend.h"
#include "zeek/storage/Manager.h"
#include "zeek/Trigger.h"
#include "zeek/Frame.h"

using namespace zeek;
using namespace zeek::storage;

static zeek::detail::trigger::TriggerPtr init_trigger(zeek::detail::Frame* frame, const BackendPtr& b) {
	auto trigger = frame->GetTrigger();

	if ( ! trigger ) {
		emit_builtin_error("Async storage operations can only be called inside when-conditions");
		return nullptr;
	}

	if ( auto timeout = trigger->TimeoutValue(); timeout < 0 ) {
		emit_builtin_error("Async Storage operations must specify a timeout block");
		return nullptr;
	}

	frame->SetDelayed();
	trigger->Hold();

	return {NewRef{}, trigger};
}
%%}

module Storage;

# Generated when a new backend connection is opened
event Storage::backend_opened%(%);

# Generated when a backend connection is lost
event Storage::backend_lost%(%);

function Storage::__open_backend%(btype: Storage::Backend, options: any, key_type: any, val_type: any, async_mode: bool%): opaque of Storage::BackendHandle
	%{
	auto btype_val = IntrusivePtr<EnumVal>{NewRef{}, btype->AsEnumVal()};
	Tag tag{btype_val};

	auto b = storage_mgr->Instantiate(tag);

	if ( ! b.has_value() ) {
		emit_builtin_error(b.error().c_str());
		return val_mgr->Bool(false);
	}

	auto bo = make_intrusive<storage::detail::BackendHandleVal>(b.value());
	OpenResultCallback* cb = nullptr;

	if ( async_mode ) {
		auto trigger = init_trigger(frame, b.value());
		if ( ! trigger )
			return val_mgr->Bool(false);

		cb = new OpenResultCallback(trigger, frame->GetTriggerAssoc(), bo.release());
	}

	auto kt = key_type->AsTypeVal()->GetType()->AsTypeType()->GetType();
	auto vt = val_type->AsTypeVal()->GetType()->AsTypeType()->GetType();
	auto options_val = IntrusivePtr<RecordVal>{NewRef{}, options->AsRecordVal()};
	auto open_res = storage_mgr->OpenBackend(b.value(), options_val, kt, vt, cb);

	if ( async_mode )
		return nullptr;

	if ( open_res.has_value() ) {
		emit_builtin_error(open_res.value().c_str());
		return val_mgr->Bool(false);
	}

	return bo;
	%}

function Storage::__close_backend%(backend: opaque of Storage::BackendHandle, async_mode: bool%) : bool
	%{
	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		emit_builtin_error("Invalid storage handle", backend);
		return val_mgr->Bool(false);
	}
	else if ( ! b->backend->IsOpen() )
		// Return true here since the backend is already closed
		return val_mgr->Bool(true);

	ErrorResultCallback* cb = nullptr;

	if ( async_mode ) {
		auto trigger = init_trigger(frame, b->backend);
		if ( ! trigger )
			return val_mgr->Bool(false);

		cb = new ErrorResultCallback(trigger, frame->GetTriggerAssoc());
	}

	auto result = storage_mgr->CloseBackend(b->backend, cb);

	if ( async_mode )
		return nullptr;

	if ( result.has_value() ) {
		emit_builtin_error(result.value().c_str());
		return val_mgr->Bool(false);
	}

	return val_mgr->Bool(true);
	%}

function Storage::__put%(backend: opaque of Storage::BackendHandle, key: any, value: any,
                         overwrite: bool, expire_time: interval, async_mode: bool &default=T%): bool
	%{
	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		emit_builtin_error("Invalid storage handle", backend);
		return val_mgr->Bool(false);
	}
	else if ( ! b->backend->IsOpen() )
		return val_mgr->Bool(false);

	ErrorResultCallback* cb = nullptr;

	if ( async_mode ) {
		auto trigger = init_trigger(frame, b->backend);
		if ( ! trigger )
			return val_mgr->Bool(false);

		cb = new ErrorResultCallback(trigger, frame->GetTriggerAssoc());
	}

	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto val_v = IntrusivePtr<Val>{NewRef{}, value};
	auto result = b->backend->Put(key_v, val_v, overwrite, expire_time, cb);

	if ( async_mode )
		return nullptr;

	if ( result.has_value() ) {
		emit_builtin_error(util::fmt("Failed to store data: %s", result.value().c_str()));
		return val_mgr->Bool(false);
	}

	return val_mgr->Bool(true);
	%}

function Storage::__get%(backend: opaque of Storage::BackendHandle, key: any, async_mode: bool &default=T%): val_result
	%{
	static auto val_result_type = id::find_type<RecordType>("val_result");
	auto val_result = make_intrusive<RecordVal>(val_result_type);

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		val_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return val_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		val_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return val_result;
	}

	ValResultCallback* cb = nullptr;

	if ( async_mode ) {
		auto trigger = init_trigger(frame, b->backend);
		if ( ! trigger ) {
			val_result->Assign(1, make_intrusive<StringVal>("Failed to create trigger"));
			return val_result;
		}

		cb = new ValResultCallback(trigger, frame->GetTriggerAssoc());
	}

	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto result = b->backend->Get(key_v, cb);

	if ( async_mode )
	   return nullptr;

	if ( ! result.has_value() ) {
		val_result->Assign(1, make_intrusive<StringVal>(
			util::fmt("Failed to retrieve data: %s", result.error().c_str())));
		return val_result;
	}

	val_result->Assign(0, result.value());
	return val_result;
	%}

function Storage::__erase%(backend: opaque of Storage::BackendHandle, key: any, async_mode: bool &default=T%): bool
	%{
	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		emit_builtin_error("Invalid storage handle", backend);
		return val_mgr->Bool(false);
	}
	else if ( ! b->backend->IsOpen() )
		return val_mgr->Bool(false);

	ErrorResultCallback* cb = nullptr;

	if ( async_mode ) {
		auto trigger = init_trigger(frame, b->backend);
		if ( ! trigger )
			return val_mgr->Bool(false);

		cb = new ErrorResultCallback(trigger, frame->GetTriggerAssoc());
	}

	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto result = b->backend->Erase(key_v, cb);

	if ( async_mode )
	   return nullptr;

	if ( result.has_value() ) {
		emit_builtin_error(util::fmt("Failed to erase data for key: %s", result.value().c_str()));
		return val_mgr->Bool(false);
	}

	return val_mgr->Bool(true);
	%}
