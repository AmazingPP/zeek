%%{
#include "zeek/Trigger.h"
#include "zeek/Frame.h"
#include "zeek/storage/Backend.h"
#include "zeek/storage/Manager.h"
#include "zeek/storage/ReturnCode.h"

using namespace zeek;
using namespace zeek::storage;

static zeek::detail::trigger::TriggerPtr init_trigger(zeek::detail::Frame* frame) {
	auto trigger = frame->GetTrigger();

	if ( ! trigger ) {
		emit_builtin_error("Asynchronous storage operations must be called via a when-condition");
		return nullptr;
	}

	if ( auto timeout = trigger->TimeoutValue(); timeout < 0 ) {
		emit_builtin_error("Async Storage operations must specify a timeout block");
		return nullptr;
	}

	frame->SetDelayed();
	trigger->Hold();

	return {NewRef{}, trigger};
}

static IntrusivePtr<storage::detail::BackendHandleVal> make_backend_handle(Val* btype) {
	auto btype_val = IntrusivePtr<EnumVal>{NewRef{}, btype->AsEnumVal()};
	Tag tag{btype_val};

	auto b = storage_mgr->Instantiate(tag);

	if ( ! b.has_value() ) {
		emit_builtin_error(b.error().c_str());
		return nullptr;
	}

	return make_intrusive<storage::detail::BackendHandleVal>(b.value());
}

%%}

module Storage;

# Generated when a new backend connection is opened
event Storage::backend_opened%(%);

# Generated when a backend connection is lost
event Storage::backend_lost%(%);

module Storage::Async;

function Storage::Async::__open_backend%(btype: Storage::Backend, options: any, key_type: any, val_type: any%): Storage::OperationResult
	%{
	auto trigger = init_trigger(frame);
	if ( ! trigger )
		return nullptr;

	auto btype_val = IntrusivePtr<EnumVal>{NewRef{}, btype->AsEnumVal()};
	Tag tag{btype_val};

	auto b = storage_mgr->Instantiate(tag);

	if ( ! b.has_value() ) {
		emit_builtin_error(util::fmt("Failed to instantiate backend: %s", b.error().c_str()));
		return nullptr;
	}

	auto bh = make_intrusive<storage::detail::BackendHandleVal>(b.value());

	auto cb = new OpenResultCallback(trigger, frame->GetTriggerAssoc(), bh);
	auto kt = key_type->AsTypeVal()->GetType()->AsTypeType()->GetType();
	auto vt = val_type->AsTypeVal()->GetType()->AsTypeType()->GetType();
	auto options_val = IntrusivePtr<RecordVal>{NewRef{}, options->AsRecordVal()};
	auto open_res = storage_mgr->OpenBackend(b.value(), options_val, kt, vt, cb);

	if ( ! b.value()->SupportsAsync() ) {
		// If the backend doesn't support async, we blocked in order to get here already. Handle the
		// callback manually.
		cb->Complete(open_res);
		delete cb;
	}
	else if ( run_state::reading_traces ) {
		// If the backend is truly async and we're reading traces, we need to fake being in sync mode
		// because otherwise time doesn't move forward correctly.
		b.value()->Poll();
	}

	return nullptr;
	%}

function Storage::Async::__close_backend%(backend: opaque of Storage::BackendHandle%) : Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");
	auto op_result = make_intrusive<RecordVal>(op_result_type);

	auto trigger = init_trigger(frame);
	if ( ! trigger )
		return nullptr;

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		op_result->Assign(0, ReturnCode::OPERATION_FAILED);
		op_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return op_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		op_result->Assign(0, ReturnCode::NOT_CONNECTED);
		op_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return op_result;
	}

	auto cb = new OperationResultCallback(trigger, frame->GetTriggerAssoc());
	auto close_res = storage_mgr->CloseBackend(b->backend, cb);

	if ( ! b->backend->SupportsAsync() ) {
		// If the backend doesn't support async, we blocked in order to get here already. Handle the
		// callback manually.
		cb->Complete(close_res);
		delete cb;
	}
	else if ( run_state::reading_traces ) {
		// If the backend is truly async and we're reading traces, we need to fake being in sync mode
		// because otherwise time doesn't move forward correctly.
		b->backend->Poll();
	}

	return nullptr;
	%}

function Storage::Async::__put%(backend: opaque of Storage::BackendHandle, key: any, value: any,
			 overwrite: bool, expire_time: interval%): Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");
	auto op_result = make_intrusive<RecordVal>(op_result_type);

	auto trigger = init_trigger(frame);
	if ( ! trigger )
		return nullptr;

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		op_result->Assign(0, ReturnCode::OPERATION_FAILED);
		op_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return op_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		op_result->Assign(0, ReturnCode::NOT_CONNECTED);
		op_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return op_result;
	}

	if ( expire_time > 0.0 )
		expire_time += run_state::network_time;

	auto cb = new OperationResultCallback(trigger, frame->GetTriggerAssoc());
	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto val_v = IntrusivePtr<Val>{NewRef{}, value};
	auto put_res = b->backend->Put(key_v, val_v, overwrite, expire_time, cb);

	if ( ! b->backend->SupportsAsync() ) {
		// If the backend doesn't support async, we blocked in order to get here already. Handle the
		// callback manually.
		cb->Complete(put_res);
		delete cb;
	}
	else if ( run_state::reading_traces ) {
		// If the backend is truly async and we're reading traces, we need to fake being in sync mode
		// because otherwise time doesn't move forward correctly.
		b->backend->Poll();
	}

	return nullptr;
	%}

function Storage::Async::__get%(backend: opaque of Storage::BackendHandle, key: any%): Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");
	auto op_result = make_intrusive<RecordVal>(op_result_type);

	auto trigger = init_trigger(frame);
	if ( ! trigger )
		return nullptr;

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		op_result->Assign(0, ReturnCode::OPERATION_FAILED);
		op_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return op_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		op_result->Assign(0, ReturnCode::NOT_CONNECTED);
		op_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return op_result;
	}

	auto cb = new OperationResultCallback(trigger, frame->GetTriggerAssoc());
	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto get_res = b->backend->Get(key_v, cb);

	if ( ! b->backend->SupportsAsync() ) {
		// If the backend doesn't support async, we blocked in order to get here already. Handle the
		// callback manually.
		cb->Complete(get_res);
		delete cb;
	}
	else if ( run_state::reading_traces ) {
		// If the backend is truly async and we're reading traces, we need to fake being in sync mode
		// because otherwise time doesn't move forward correctly.
		b->backend->Poll();
	}

	return nullptr;
	%}

function Storage::Async::__erase%(backend: opaque of Storage::BackendHandle, key: any%): Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");
	auto op_result = make_intrusive<RecordVal>(op_result_type);

	auto trigger = init_trigger(frame);
	if ( ! trigger )
		return nullptr;

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		op_result->Assign(0, ReturnCode::OPERATION_FAILED);
		op_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return op_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		op_result->Assign(0, ReturnCode::NOT_CONNECTED);
		op_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return op_result;
	}

	auto cb = new OperationResultCallback(trigger, frame->GetTriggerAssoc());
	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto erase_res = b->backend->Erase(key_v, cb);

	if ( ! b->backend->SupportsAsync() ) {
		// If the backend doesn't support async, we blocked in order to get here already. Handle the
		// callback manually.
		cb->Complete(erase_res);
		delete cb;
	}
	else if ( run_state::reading_traces ) {
		// If the backend is truly async and we're reading traces, we need to fake being in sync mode
		// because otherwise time doesn't move forward correctly.
		b->backend->Poll();
	}

	return nullptr;
	%}

module Storage::Sync;

function Storage::Sync::__open_backend%(btype: Storage::Backend, options: any, key_type: any, val_type: any%): Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");

	auto btype_val = IntrusivePtr<EnumVal>{NewRef{}, btype->AsEnumVal()};
	Tag tag{btype_val};

	auto b = storage_mgr->Instantiate(tag);

	if ( ! b.has_value() ) {
		emit_builtin_error(b.error().c_str());
		return val_mgr->Bool(false);
	}

	auto bh = make_intrusive<storage::detail::BackendHandleVal>(b.value());

	auto cb = new OpenResultCallback(bh);
	auto kt = key_type->AsTypeVal()->GetType()->AsTypeType()->GetType();
	auto vt = val_type->AsTypeVal()->GetType()->AsTypeType()->GetType();
	auto options_val = IntrusivePtr<RecordVal>{NewRef{}, options->AsRecordVal()};
	auto open_res = storage_mgr->OpenBackend(b.value(), options_val, kt, vt, cb);

	// If the backend only supports async, block until it's ready and then pull the result out of
	// the callback.
	if ( ! b.value()->SupportsSync() ) {
		b.value()->Poll();
		open_res = cb->Result();
	}

	delete cb;

	return open_res.BuildVal();
	%}

function Storage::Sync::__close_backend%(backend: opaque of Storage::BackendHandle%) : Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		auto op_result = make_intrusive<RecordVal>(op_result_type);
		op_result->Assign(0, ReturnCode::OPERATION_FAILED);
		op_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return op_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		auto op_result = make_intrusive<RecordVal>(op_result_type);
		op_result->Assign(0, ReturnCode::NOT_CONNECTED);
		op_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return op_result;
	}

	auto cb = new OperationResultCallback();
	auto close_res = storage_mgr->CloseBackend(b->backend, cb);

	// If the backend only supports async, block until it's ready and then pull the result out of
	// the callback.
	if ( ! b->backend->SupportsSync() ) {
		b->backend->Poll();
		close_res = cb->Result();
	}

	delete cb;

	return close_res.BuildVal();
	%}

function Storage::Sync::__put%(backend: opaque of Storage::BackendHandle, key: any, value: any,
			 overwrite: bool, expire_time: interval%): Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		auto op_result = make_intrusive<RecordVal>(op_result_type);
		op_result->Assign(0, ReturnCode::OPERATION_FAILED);
		op_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return op_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		auto op_result = make_intrusive<RecordVal>(op_result_type);
		op_result->Assign(0, ReturnCode::NOT_CONNECTED);
		op_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return op_result;
	}

	if ( expire_time > 0.0 )
		expire_time += run_state::network_time;

	auto cb = new OperationResultCallback();
	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto val_v = IntrusivePtr<Val>{NewRef{}, value};
	auto put_res = b->backend->Put(key_v, val_v, overwrite, expire_time, cb);

	// If the backend only supports async, block until it's ready and then pull the result out of
	// the callback.
	if ( ! b->backend->SupportsSync() ) {
		b->backend->Poll();
		put_res = cb->Result();
	}

	delete cb;

	return put_res.BuildVal();
	%}

function Storage::Sync::__get%(backend: opaque of Storage::BackendHandle, key: any%): Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		auto op_result = make_intrusive<RecordVal>(op_result_type);
		op_result->Assign(0, ReturnCode::OPERATION_FAILED);
		op_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return op_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		auto op_result = make_intrusive<RecordVal>(op_result_type);
		op_result->Assign(0, ReturnCode::NOT_CONNECTED);
		op_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return op_result;
	}

	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto cb = new OperationResultCallback();
	auto get_res = b->backend->Get(key_v, cb);

	// If the backend only supports async, block until it's ready and then pull the result out of
	// the callback.
	if ( ! b->backend->SupportsSync() ) {
		b->backend->Poll();
		get_res = cb->Result();
	}

	delete cb;

	return get_res.BuildVal();
	%}

function Storage::Sync::__erase%(backend: opaque of Storage::BackendHandle, key: any%): Storage::OperationResult
	%{
	static auto op_result_type = id::find_type<RecordType>("Storage::OperationResult");

	auto b = dynamic_cast<storage::detail::BackendHandleVal*>(backend);
	if ( ! b ) {
		auto op_result = make_intrusive<RecordVal>(op_result_type);
		op_result->Assign(0, ReturnCode::OPERATION_FAILED);
		op_result->Assign(1, make_intrusive<StringVal>("Invalid storage handlle"));
		return op_result;
	}
	else if ( ! b->backend->IsOpen() ) {
		auto op_result = make_intrusive<RecordVal>(op_result_type);
		op_result->Assign(0, ReturnCode::NOT_CONNECTED);
		op_result->Assign(1, make_intrusive<StringVal>("Backend is closed"));
		return op_result;
	}

	auto cb = new OperationResultCallback();
	auto key_v = IntrusivePtr<Val>{NewRef{}, key};
	auto erase_res = b->backend->Erase(key_v, cb);

	// If the backend only supports async, block until it's ready and then pull the result out of
	// the callback.
	if ( ! b->backend->SupportsSync() ) {
		b->backend->Poll();
		erase_res = cb->Result();
	}

	delete cb;

	return erase_res.BuildVal();
	%}
